/*
 * Copyright (C) 2016 - 2019 Xilinx, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 *
 */
/****************************user add******************/
#include "sys_core.h"
#include "lwip/sockets.h"
#include "lwip/err.h"
#include "xadcps.h" // XADC 驱动
/**********************************************************/
#include <stdio.h>
#include "xparameters.h"
#include "netif/xadapter.h"
#include "platform_config.h"
#include "xil_printf.h"
#include "xgpiops.h"
#include "sleep.h"
/* 把这两行加在 main.c 最上面的 include 下面 */
extern void Task_LED_Logic(void *pvParameters);
extern void Task_UART_Cmd(void *pvParameters);
// --- 全局网络变量 ---
int g_udp_sock = -1;                 // Socket 句柄
struct sockaddr_in g_pc_addr;        // 电脑的 IP 地址
int g_pc_connected = 0;              // 标记是否收到过电脑的指令

// --- 发送函数：供外部调用 ---
void UDP_Send_Log(char* msg) {
    if (g_udp_sock >= 0 && g_pc_connected) {
        lwip_sendto(g_udp_sock, msg, strlen(msg), 0,
                   (struct sockaddr *)&g_pc_addr, sizeof(g_pc_addr));
    }
}
/*********************************************/
#if LWIP_IPV6==1
#include "lwip/ip.h"
#else
#if LWIP_DHCP==1
#include "lwip/dhcp.h"
#endif
#endif

#ifdef XPS_BOARD_ZCU102
#ifdef XPAR_XIICPS_0_DEVICE_ID
int IicPhyReset(void);
#endif
#endif
XGpioPs Gpio;
int main_thread();
void print_echo_app_header();
void echo_application_thread(void *);

void lwip_init();

#if LWIP_IPV6==0
#if LWIP_DHCP==1
extern volatile int dhcp_timoutcntr;
err_t dhcp_start(struct netif *netif);
#endif
#endif

#define THREAD_STACKSIZE 1024

static struct netif server_netif;
struct netif *echo_netif;

#if LWIP_IPV6==1
void print_ip6(char *msg, ip_addr_t *ip)
{
	print(msg);
	xil_printf(" %x:%x:%x:%x:%x:%x:%x:%x\n\r",
			IP6_ADDR_BLOCK1(&ip->u_addr.ip6),
			IP6_ADDR_BLOCK2(&ip->u_addr.ip6),
			IP6_ADDR_BLOCK3(&ip->u_addr.ip6),
			IP6_ADDR_BLOCK4(&ip->u_addr.ip6),
			IP6_ADDR_BLOCK5(&ip->u_addr.ip6),
			IP6_ADDR_BLOCK6(&ip->u_addr.ip6),
			IP6_ADDR_BLOCK7(&ip->u_addr.ip6),
			IP6_ADDR_BLOCK8(&ip->u_addr.ip6));
}

#else
// ================= XADC 监控功能 =================
XAdcPs XAdcInst; // XADC 驱动实例

// 初始化 XADC
int Init_XADC(void) {
    XAdcPs_Config *ConfigPtr;
    ConfigPtr = XAdcPs_LookupConfig(XPAR_XADCPS_0_DEVICE_ID);
    if (ConfigPtr == NULL) return XST_FAILURE;

    XAdcPs_CfgInitialize(&XAdcInst, ConfigPtr, ConfigPtr->BaseAddress);

    // 设置为“安全模式” (默认序列)
    XAdcPs_SetSequencerMode(&XAdcInst, XADCPS_SEQ_MODE_SAFE);
    return XST_SUCCESS;
}

// 读取温度并转换为字符串
// 格式: "Temp: 45.2 C"
void Read_Chip_Temp(char *buffer) {
    u16 raw_data = XAdcPs_GetAdcData(&XAdcInst, XADCPS_CH_TEMP);
    // 官方转换公式: Temp = (Raw * 503.975 / 65536) - 273.15
    float temp = ((float)raw_data * 503.975f / 65536.0f) - 273.15f;

    // 简单的 float 转 string (因为 xil_printf 对 %f 支持不好)
    int temp_int = (int)temp;
    int temp_frac = (int)((temp - temp_int) * 10); // 取一位小数
    sprintf(buffer, "Temp: %d.%d C", temp_int, temp_frac);
}

// 读取 VCCINT 电压并转换为字符串
// 格式: "Vcc: 0.99 V"
void Read_Chip_Vcc(char *buffer) {
    u16 raw_data = XAdcPs_GetAdcData(&XAdcInst, XADCPS_CH_VCCINT);
    // 官方转换公式: Volts = Raw * 3.0 / 65536
    float vcc = (float)raw_data * 3.0f / 65536.0f;

    int vcc_int = (int)vcc;
    int vcc_frac = (int)((vcc - vcc_int) * 100); // 取两位小数
    sprintf(buffer, "Vcc: %d.%02d V", vcc_int, vcc_frac);
}
void
print_ip(char *msg, ip_addr_t *ip)
{
	xil_printf(msg);
	xil_printf("%d.%d.%d.%d\n\r", ip4_addr1(ip), ip4_addr2(ip),
			ip4_addr3(ip), ip4_addr4(ip));
}

void
print_ip_settings(ip_addr_t *ip, ip_addr_t *mask, ip_addr_t *gw)
{

	print_ip("Board IP: ", ip);
	print_ip("Netmask : ", mask);
	print_ip("Gateway : ", gw);
}

#endif
#define PHY_RESET_PIN  47  // ZC706 专用复位脚
/**************************************************/
void Reset_Phy_MIO47(void) {

    XGpioPs_Config *ConfigPtr;

    xil_printf(">> Start PHY Reset via MIO %d...\r\n", PHY_RESET_PIN);

    ConfigPtr = XGpioPs_LookupConfig(XPAR_PS7_GPIO_0_DEVICE_ID);
    XGpioPs_CfgInitialize(&Gpio, ConfigPtr, ConfigPtr->BaseAddr);

    XGpioPs_SetDirectionPin(&Gpio, PHY_RESET_PIN, 1); // Output
    XGpioPs_SetOutputEnablePin(&Gpio, PHY_RESET_PIN, 1); // Enable

    XGpioPs_WritePin(&Gpio, PHY_RESET_PIN, 0); // 拉低复位
    usleep(10000);  // 等 10ms
    XGpioPs_WritePin(&Gpio, PHY_RESET_PIN, 1); // 拉高工作
    usleep(200000); // 等 200ms 让芯片醒透

    xil_printf(">> PHY Reset Done.\r\n");
}
/****************************************************/
int main()
{
	sys_thread_new("main_thrd", (void(*)(void*))main_thread, 0,
	                THREAD_STACKSIZE,
	                DEFAULT_THREAD_PRIO);
	vTaskStartScheduler();
	while(1);
	return 0;
}
/* ============================================================
 * UDP 指令接收任务
 * 监听端口: 5001
 * 功能: 接收电脑发来的指令字符，切换游戏模式
 * ============================================================ */
void udp_cmd_thread(void *p)
{
    int sock;
    struct sockaddr_in server_addr, client_addr;
    int addr_len = sizeof(client_addr);
    char recv_buf[100];
    int n;

    xil_printf(">> [UDP] Starting UDP Listener on Port 5001...\r\n");

    if ((sock = lwip_socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        xil_printf(">> [UDP] Error creating socket!\r\n");
        vTaskDelete(NULL);
        return;
    }

    // 【关键】赋值给全局变量，让 Send 函数也能用
    g_udp_sock = sock;

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(5001);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (lwip_bind(sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        xil_printf(">> [UDP] Error binding socket!\r\n");
        close(sock);
        vTaskDelete(NULL);
        return;
    }

    xil_printf(">> [UDP] Listening...\r\n");

    while (1) {
        n = lwip_recvfrom(sock, recv_buf, sizeof(recv_buf) - 1, 0,
                          (struct sockaddr *)&client_addr, (socklen_t *)&addr_len);

        if (n > 0) {
            // 【关键】一旦收到电脑指令，就记下电脑的 IP 地址
            memcpy(&g_pc_addr, &client_addr, sizeof(client_addr));
            g_pc_connected = 1; // 标记已连接

            recv_buf[n] = 0;
            char cmd = recv_buf[0];
            xil_printf(">> [UDP] Recv: %c\r\n", cmd);

            // 切换模式逻辑
            if (cmd >= '0' && cmd <= '6') {
                switch(cmd) {
                    case '1': g_CurrentMode = MODE_WATERFALL;   break;
                    case '2': g_CurrentMode = MODE_SWITCH_CTRL; break;
                    case '3': g_CurrentMode = MODE_BINARY_CNT;  break;
                    case '4': g_CurrentMode = MODE_DICE_GAME;   break;
                    case '5': g_CurrentMode = MODE_REFLEX_GAME; break;
                    case '6': g_CurrentMode = MODE_SOS_SIGNAL;  break;
                    case '0': g_CurrentMode = MODE_OFF;         break;
                }

                // 立即回复电脑
                char *reply = "OK: Mode Switched";
                lwip_sendto(sock, reply, strlen(reply), 0, (struct sockaddr *)&client_addr, addr_len);
            }
        }
    }
}
/******************************************************************************/
void network_thread(void *p)
{
    struct netif *netif;
    /* the mac address of the board. this should be unique per board */
    unsigned char mac_ethernet_address[] = { 0x00, 0x0a, 0x35, 0x00, 0x01, 0x02 };
#if LWIP_IPV6==0
    ip_addr_t ipaddr, netmask, gw;
#if LWIP_DHCP==1
    int mscnt = 0;
#endif
#endif

    netif = &server_netif;

    xil_printf("\r\n\r\n");
    xil_printf("-----lwIP Socket Mode Echo server Demo Application ------\r\n");

#if LWIP_IPV6==0
#if LWIP_DHCP==0
    /* initialize IP addresses to be used */
    IP4_ADDR(&ipaddr,  192, 168, 0, 20);
    IP4_ADDR(&netmask, 255, 255, 255,  0);
    IP4_ADDR(&gw,      192, 168, 0, 1);
#endif

    /* print out IP settings of the board */

#if LWIP_DHCP==0
    print_ip_settings(&ipaddr, &netmask, &gw);
    /* print all application headers */
#endif

#if LWIP_DHCP==1
	ipaddr.addr = 0;
	gw.addr = 0;
	netmask.addr = 0;
#endif
#endif

#if LWIP_IPV6==0
    /* Add network interface to the netif_list, and set it as default */
    if (!xemac_add(netif, &ipaddr, &netmask, &gw, mac_ethernet_address, PLATFORM_EMAC_BASEADDR)) {
	xil_printf("Error adding N/W interface\r\n");
	return;
    }
#else
    /* Add network interface to the netif_list, and set it as default */
    if (!xemac_add(netif, NULL, NULL, NULL, mac_ethernet_address, PLATFORM_EMAC_BASEADDR)) {
	xil_printf("Error adding N/W interface\r\n");
	return;
    }

    netif->ip6_autoconfig_enabled = 1;

    netif_create_ip6_linklocal_address(netif, 1);
    netif_ip6_addr_set_state(netif, 0, IP6_ADDR_VALID);

    print_ip6("\n\rBoard IPv6 address ", &netif->ip6_addr[0].u_addr.ip6);
#endif

    netif_set_default(netif);

    /* specify that the network if is up */
    netif_set_up(netif);

    /* start packet receive thread - required for lwIP operation */
    sys_thread_new("xemacif_input_thread", (void(*)(void*))xemacif_input_thread, netif,
            THREAD_STACKSIZE,
            DEFAULT_THREAD_PRIO);

#if LWIP_IPV6==0
#if LWIP_DHCP==1
    dhcp_start(netif);
    while (1) {
		vTaskDelay(DHCP_FINE_TIMER_MSECS / portTICK_RATE_MS);
		dhcp_fine_tmr();
		mscnt += DHCP_FINE_TIMER_MSECS;
		if (mscnt >= DHCP_COARSE_TIMER_SECS*1000) {
			dhcp_coarse_tmr();
			mscnt = 0;
		}
	}
#else
    xil_printf("\r\n");
    xil_printf("%20s %6s %s\r\n", "Server", "Port", "Connect With..");
    xil_printf("%20s %6s %s\r\n", "--------------------", "------", "--------------------");

    print_echo_app_header();
    xil_printf("\r\n");
    sys_thread_new("echod", echo_application_thread, 0,
		THREAD_STACKSIZE,
		DEFAULT_THREAD_PRIO);
    vTaskDelete(NULL);
#endif
#else
    print_echo_app_header();
    xil_printf("\r\n");
    sys_thread_new("echod",echo_application_thread, 0,
		THREAD_STACKSIZE,
		DEFAULT_THREAD_PRIO);
    vTaskDelete(NULL);
#endif
    return;
}

int main_thread()
{
#if LWIP_DHCP==1
	int mscnt = 0;
#endif

/**************************/
	Reset_Phy_MIO47();
	if(Init_XADC() == XST_SUCCESS) {
	        xil_printf(">> [Init] XADC Sensor Initialized.\r\n");
	    }
/***************************/
#ifdef XPS_BOARD_ZCU102
	IicPhyReset();
#endif

	/* initialize lwIP before calling sys_thread_new */
    lwip_init();

    /* any thread using lwIP should be created using sys_thread_new */
    sys_thread_new("NW_THRD", network_thread, NULL,
		THREAD_STACKSIZE,
            DEFAULT_THREAD_PRIO);
    sys_thread_new("UDP_THRD", udp_cmd_thread, NULL, 1024, DEFAULT_THREAD_PRIO);
    // 4. 【新增】启动你的 LED 游戏任务！(放在这里最合适)
        // ----------------------------------------------------------------
        xil_printf(">> Starting LED Game System...\r\n");
        // 优先级建议设为 tskIDLE_PRIORITY + 1 或更高
        xTaskCreate(Task_LED_Logic, "LED_Core", 1024, NULL, tskIDLE_PRIORITY + 1, NULL);
        xTaskCreate(Task_UART_Cmd,  "CMD_Port", 1024, NULL, tskIDLE_PRIORITY + 1, NULL);
        // ----------------------------------------------------------------
#if LWIP_IPV6==0
#if LWIP_DHCP==1
    while (1) {
	vTaskDelay(DHCP_FINE_TIMER_MSECS / portTICK_RATE_MS);
		if (server_netif.ip_addr.addr) {
			xil_printf("DHCP request success\r\n");
			print_ip_settings(&(server_netif.ip_addr), &(server_netif.netmask), &(server_netif.gw));
			print_echo_app_header();
			xil_printf("\r\n");
			sys_thread_new("echod", echo_application_thread, 0,
					THREAD_STACKSIZE,
					DEFAULT_THREAD_PRIO);
			break;
		}
		mscnt += DHCP_FINE_TIMER_MSECS;
		if (mscnt >= DHCP_COARSE_TIMER_SECS * 2000) {
			xil_printf("ERROR: DHCP request timed out\r\n");
			xil_printf("Configuring default IP of 192.168.1.10\r\n");
			IP4_ADDR(&(server_netif.ip_addr),  192, 168, 1, 10);
			IP4_ADDR(&(server_netif.netmask), 255, 255, 255,  0);
			IP4_ADDR(&(server_netif.gw),  192, 168, 1, 1);
			print_ip_settings(&(server_netif.ip_addr), &(server_netif.netmask), &(server_netif.gw));
			/* print all application headers */
			xil_printf("\r\n");
			xil_printf("%20s %6s %s\r\n", "Server", "Port", "Connect With..");
			xil_printf("%20s %6s %s\r\n", "--------------------", "------", "--------------------");

			print_echo_app_header();
			xil_printf("\r\n");
			sys_thread_new("echod", echo_application_thread, 0,
					THREAD_STACKSIZE,
					DEFAULT_THREAD_PRIO);
			break;
		}
	}
#endif
#endif
    vTaskDelete(NULL);
    return 0;
}
