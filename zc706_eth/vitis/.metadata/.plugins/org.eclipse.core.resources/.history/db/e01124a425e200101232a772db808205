#include "FreeRTOS.h"
#include "task.h"
#include "sys_core.h"
#include "sleep.h"
#include "stdlib.h"
#include "xil_printf.h"

// 辅助函数：设置 4 个灯
static void Set_Leds(int l1, int l2, int l3, int l4) {
    XGpioPs_WritePin(&Gpio, LED1_PIN, l1);
    XGpioPs_WritePin(&Gpio, LED2_PIN, l2);
    XGpioPs_WritePin(&Gpio, LED3_PIN, l3);
    XGpioPs_WritePin(&Gpio, LED4_PIN, l4);
}

// 辅助函数：二进制显示
static void Show_Binary(u8 val) {
    Set_Leds((val>>3)&1, (val>>2)&1, (val>>1)&1, (val>>0)&1);
}

// 辅助函数：骰子动画
static void Play_Dice_Animation() {
    for(int i=0; i<15; i++) {
        Show_Binary(rand() % 16);
        usleep(50000 + (i * 10000));
    }
}

void Task_LED_Logic(void *pvParameters)
{
    const TickType_t xDelayWaterfall = pdMS_TO_TICKS(150);
    int counter = 0;
    int last_sw_state = 0;
    int game_state = 0; // 0=Wait, 1=Ready, 2=Go
    TickType_t start_time = 0;

    // 获取初始开关状态
    last_sw_state = XGpioPs_ReadPin(&Gpio, SW_BASE_PIN + 0);

    for (;;) {
        switch (g_CurrentMode) {
            // ... (前面的模式 0,1,2,3 保持不变，为了篇幅我省略了，请保留之前的代码) ...

            case MODE_WATERFALL:
                // (粘贴你之前的流水灯代码)
                 Set_Leds(1, 0, 0, 0); vTaskDelay(xDelayWaterfall);
                 Set_Leds(0, 1, 0, 0); vTaskDelay(xDelayWaterfall);
                 Set_Leds(0, 0, 1, 0); vTaskDelay(xDelayWaterfall);
                 Set_Leds(0, 0, 0, 1); vTaskDelay(xDelayWaterfall);
                 break; // 简写示意

            case MODE_SWITCH_CTRL:
                // (粘贴你之前的开关控制代码)
                for(int i=0; i<4; i++) {
                     int led_map[4] = {LED1_PIN, LED2_PIN, LED3_PIN, LED4_PIN};
                     XGpioPs_WritePin(&Gpio, led_map[i], XGpioPs_ReadPin(&Gpio, SW_BASE_PIN+i));
                }
                vTaskDelay(pdMS_TO_TICKS(50));
                break;

            case MODE_BINARY_CNT:
                // (粘贴你之前的二进制代码)
                 counter++;
                 if(counter > 15) counter = 0;
                 Show_Binary(counter);
                 vTaskDelay(pdMS_TO_TICKS(200));
                 break; // 简写

            case MODE_DICE_GAME:
                // (粘贴你之前的骰子代码)
                 // ... 请保留之前的逻辑，这里只展示新加的 ...
                 vTaskDelay(pdMS_TO_TICKS(100));
                 break;

            // --- 【新】模式 4: 反应力测试 ---
            case MODE_REFLEX_GAME:
            {
                // 阶段 0: 准备开始，全灭，等待随机时间
                if (game_state == 0) {
                    Set_Leds(0, 0, 0, 0);
                    xil_printf(">> Ready... Wait for Light!\r\n");

                    // 随机延时 2秒 ~ 5秒
                    int random_delay = 2000 + (rand() % 3000);
                    vTaskDelay(pdMS_TO_TICKS(random_delay));

                    // 突然全亮！
                    Set_Leds(1, 1, 1, 1);
                    start_time = xTaskGetTickCount(); // 记录当前时刻
                    game_state = 1; // 进入检测状态
                }

                // 阶段 1: 等待玩家拨动 SW1
                else if (game_state == 1) {
                    int curr_sw = XGpioPs_ReadPin(&Gpio, SW_BASE_PIN + 0);

                    // 检测 SW1 是否变化 (不管是从0变1，还是1变0，只要动了就行)
                    if (curr_sw != last_sw_state) {
                        TickType_t end_time = xTaskGetTickCount();
                        // 计算毫秒差 (FreeRTOS Tick 默认 100Hz = 10ms，或者 1000Hz = 1ms)
                        // 使用 portTICK_PERIOD_MS 转换
                        int diff_ms = (end_time - start_time) * portTICK_PERIOD_MS;

                        xil_printf(">> BOOM! Your Time: %d ms\r\n", diff_ms);

                        if(diff_ms < 200) xil_printf(">> RANK: GODLIKE!\r\n");
                        else if(diff_ms < 300) xil_printf(">> RANK: Normal.\r\n");
                        else xil_printf(">> RANK: Too Slow...\r\n");

                        last_sw_state = curr_sw; // 更新状态
                        game_state = 2; // 结束本轮
                    }
                }

                // 阶段 2: 休息一下，自动重开
                else if (game_state == 2) {
                    Set_Leds(0, 1, 1, 0); // 亮中间灯示意结束
                    vTaskDelay(pdMS_TO_TICKS(2000)); // 休息2秒
                    game_state = 0; // 重置游戏
                }

                vTaskDelay(pdMS_TO_TICKS(10)); // 高速轮询
                break;
            }

            // --- 【新】模式 5: SOS 信号 ---
            case MODE_SOS_SIGNAL:
            {
                // S (...)
                for(int i=0; i<3; i++) { Set_Leds(1,1,1,1); vTaskDelay(pdMS_TO_TICKS(100)); Set_Leds(0,0,0,0); vTaskDelay(pdMS_TO_TICKS(100)); }
                vTaskDelay(pdMS_TO_TICKS(300)); // 字母间隔

                // O (---)
                for(int i=0; i<3; i++) { Set_Leds(1,1,1,1); vTaskDelay(pdMS_TO_TICKS(400)); Set_Leds(0,0,0,0); vTaskDelay(pdMS_TO_TICKS(100)); }
                vTaskDelay(pdMS_TO_TICKS(300));

                // S (...)
                for(int i=0; i<3; i++) { Set_Leds(1,1,1,1); vTaskDelay(pdMS_TO_TICKS(100)); Set_Leds(0,0,0,0); vTaskDelay(pdMS_TO_TICKS(100)); }

                vTaskDelay(pdMS_TO_TICKS(1500)); // 单词间隔
                break;
            }

            default:
                Set_Leds(0, 0, 0, 0);
                vTaskDelay(pdMS_TO_TICKS(100));
                break;
        }
    }
}
