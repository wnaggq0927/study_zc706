#include "FreeRTOS.h"
#include "task.h"
#include "sys_core.h"
#include "sleep.h"

// 辅助函数：设置 4 个灯的状态 (逻辑顺序 1->2->3->4)
static void Set_Leds(int l1, int l2, int l3, int l4) {
    XGpioPs_WritePin(&Gpio, LED1_PIN, l1);
    XGpioPs_WritePin(&Gpio, LED2_PIN, l2);
    XGpioPs_WritePin(&Gpio, LED3_PIN, l3);
    XGpioPs_WritePin(&Gpio, LED4_PIN, l4);
}

// Gamma 表 (保持不变)
static const int gamma_steps[] = {
      0,   2,   5,  10,  18,  30,  50,  80,
    120, 180, 260, 360, 480, 620, 800, 1000,
   1250, 1550, 1900, 2000
};
#define GAMMA_STEPS_COUNT (sizeof(gamma_steps)/sizeof(gamma_steps[0]))

void Task_LED_Logic(void *pvParameters)
{
    const TickType_t xFastDelay = pdMS_TO_TICKS(150);
    const TickType_t xSlowDelay = pdMS_TO_TICKS(500);
    const int speed_factor = 45; // 呼吸速度

    // 【关键】建立一个查找表，把逻辑顺序映射到物理乱序
    // 下标 0 (SW1) -> 控制 LED1_PIN (57)
    // 下标 1 (SW2) -> 控制 LED2_PIN (55) ...
    const int led_map[4] = {LED1_PIN, LED2_PIN, LED3_PIN, LED4_PIN};

    for (;;) {
        switch (g_CurrentMode) {
            // --- 模式 0: 4灯流水 (现在是从左到右了!) ---
            case MODE_WATERFALL:
                Set_Leds(1, 0, 0, 0); vTaskDelay(xFastDelay); // 左1
                Set_Leds(0, 1, 0, 0); vTaskDelay(xFastDelay); // 左2
                Set_Leds(0, 0, 1, 0); vTaskDelay(xFastDelay); // 左3
                Set_Leds(0, 0, 0, 1); vTaskDelay(xFastDelay); // 左4
                // 回马枪 (右->左)
                Set_Leds(0, 0, 1, 0); vTaskDelay(xFastDelay);
                Set_Leds(0, 1, 0, 0); vTaskDelay(xFastDelay);
                break;

            // --- 模式 1: 4灯爆闪 ---
            case MODE_ALL_BLINK:
                Set_Leds(1, 1, 1, 1); vTaskDelay(xSlowDelay);
                Set_Leds(0, 0, 0, 0); vTaskDelay(xSlowDelay);
                break;

            // --- 模式 2: 4灯呼吸 ---
            case MODE_BREATH_SIM: {
                int period = 2000;
                // 渐亮
                for(int i = 0; i < GAMMA_STEPS_COUNT; i++) {
                    int on = gamma_steps[i]; int off = period - on;
                    for(int k=0; k < speed_factor; k++) {
                        if(on>0) { Set_Leds(1,1,1,1); usleep(on); }
                        if(off>0){ Set_Leds(0,0,0,0); usleep(off); }
                    }
                }
                Set_Leds(1,1,1,1); vTaskDelay(pdMS_TO_TICKS(500));
                // 渐灭
                for(int i = GAMMA_STEPS_COUNT - 1; i >= 0; i--) {
                    int on = gamma_steps[i]; int off = period - on;
                    for(int k=0; k < speed_factor; k++) {
                        if(on>0) { Set_Leds(1,1,1,1); usleep(on); }
                        if(off>0){ Set_Leds(0,0,0,0); usleep(off); }
                    }
                }
                Set_Leds(0,0,0,0); vTaskDelay(pdMS_TO_TICKS(500));
                break;
            }

            // --- 模式 3: 开关直控模式 ---
            case MODE_SWITCH_CTRL: {
                // 遍历 4 个开关
                for(int i=0; i<4; i++) {
                    // 读开关 (顺序是线性的: 58, 59, 60, 61)
                    int sw_val = XGpioPs_ReadPin(&Gpio, SW_BASE_PIN + i);

                    // 【修正】写 LED (使用查找表，确保 SW1 对应 LED1-57)
                    XGpioPs_WritePin(&Gpio, led_map[i], sw_val);
                }
                vTaskDelay(pdMS_TO_TICKS(20));
                break;
            }

            // --- 默认: 全关 ---
            default: // MODE_OFF
                Set_Leds(0, 0, 0, 0);
                vTaskDelay(pdMS_TO_TICKS(100));
                break;
        }
    }
}
