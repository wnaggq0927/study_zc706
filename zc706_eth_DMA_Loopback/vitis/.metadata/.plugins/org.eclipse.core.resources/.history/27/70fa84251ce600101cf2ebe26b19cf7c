/* src/task_led.c - 逻辑实现 (双显版) */
#include "sys_core.h"
#include "FreeRTOS.h"
#include "task.h"
#include "xil_printf.h"
#include "xil_cache.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "xtime_l.h"
#include <math.h>
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif
/* src/task_led.c 中的 Task_DMA_Wave 函数 */

/* src/task_led.c */
void Task_DMA_Wave(void *pvParameters) {
    u8 *TxBufferPtr = (u8 *)TX_BUFFER_BASE;
    u8 *RxBufferPtr = (u8 *)RX_BUFFER_BASE;

    const int TEST_LEN = 1024 * 8; // 8KB
    const int UDP_CHUNK_SIZE = 1024;
    char report_buf[128];
    int print_cnt = 0;

    // 【新增】定义高精度计时变量
    XTime tEnd, tStart;

    vTaskDelay(pdMS_TO_TICKS(5000));
    xil_printf(">> Task_DMA_Stress_Test Started! Length: %d Bytes\r\n", TEST_LEN);

    for(;;) {
        if (g_CurrentMode == MODE_WAVE_OSCILLO && g_pc_connected) {

        	// 1. 准备数据 (生成正弦波)
        	            // 只要修改这里，你的 Python 绘图就会变成正弦波
        	            for(int i = 0; i < TEST_LEN; i++) {
        	                // 生成一个周期为 256 个点的正弦波
        	                // 放大到 0-255 范围 (u8)
        	                // sin 的结果是 -1 到 +1，所以 +1 变成 0-2，再乘 127.5 变成 0-255
        	                float val = sin(2 * M_PI * i / 256.0);
        	                TxBufferPtr[i] = (u8)((int8_t)(val * 127.0f));
        	            }
        	            xil_printf(">> Data Check: ");
        	                        for(int k=0; k<10; k++) {
        	                            xil_printf("%d ", TxBufferPtr[k]);
        	                        }
        	                        xil_printf("\r\n");
            Xil_DCacheFlushRange((UINTPTR)TxBufferPtr, TEST_LEN);
            Xil_DCacheInvalidateRange((UINTPTR)RxBufferPtr, TEST_LEN);
            // --- 【修改】计时开始 (纳秒级) ---
            XTime_GetTime(&tStart);

            // 3. 启动 DMA (保持不变)
            int StatusRx = XAxiDma_SimpleTransfer(&AxiDma, (UINTPTR)RxBufferPtr,
                                            TEST_LEN, XAXIDMA_DEVICE_TO_DMA);
            int StatusTx = XAxiDma_SimpleTransfer(&AxiDma, (UINTPTR)TxBufferPtr,
                                            TEST_LEN, XAXIDMA_DMA_TO_DEVICE);

            if (StatusTx == XST_SUCCESS && StatusRx == XST_SUCCESS) {
                // 4. 等待完成 (保持不变)
                int timeout = 0;
                while (XAxiDma_Busy(&AxiDma, XAXIDMA_DMA_TO_DEVICE) ||
                       XAxiDma_Busy(&AxiDma, XAXIDMA_DEVICE_TO_DMA)) {
                    // 注意：这里不要加 vTaskDelay(1)，因为 1ms 对 DMA 来说太久了
                    // 纯轮询以获得最准确的测速
                    timeout++;
                    if(timeout > 10000000) { // 简单的大数防死锁
                        xil_printf("!! DMA Timeout !!\r\n");
                        break;
                    }
                }

                // --- 【修改】计时结束 ---
                XTime_GetTime(&tEnd);

                if(timeout <= 10000000) {
                    Xil_DCacheInvalidateRange((UINTPTR)RxBufferPtr, TEST_LEN);

                    // 5. 【核心修改】计算高精度速度
                    // COUNTS_PER_SECOND 是硬件定义的每秒计数值 (通常是 CPU 频率的一半)
                    // 计算消耗的微秒数 (us)
                    u64 time_diff_ticks = tEnd - tStart;
                    float time_us = (float)time_diff_ticks / (COUNTS_PER_SECOND / 1000000.0f);

                    // 防止除以0
                    if(time_us < 1.0f) time_us = 1.0f;

                    // 速度 = 字节 / 微秒 = MB / 秒
                    // (Bytes / 1024 / 1024) / (us / 1000000) = MB/s
                    float speed_mbs = ((float)TEST_LEN / 1024.0f / 1024.0f) / (time_us / 1000000.0f);

                    // 拆分整数小数以便打印
                    int speed_int = (int)speed_mbs;
                    int speed_frac = (int)((speed_mbs - speed_int) * 100);
                    int time_us_int = (int)time_us;

                    xil_printf("[%d] 8KB Done. Time: %d us, Speed: %d.%02d MB/s\r\n",
                               print_cnt, time_us_int, speed_int, speed_frac);

                    // 6. 发送 UDP (逻辑不变，更新 sprintf 即可)
                    sprintf(report_buf, "[START] %d B, %d.%02d MB/s", TEST_LEN, speed_int, speed_frac);
                    UDP_Send_Log(report_buf);

                    int remaining = TEST_LEN;
                    int offset = 0;
                    while(remaining > 0) {
                        int chunk = (remaining > UDP_CHUNK_SIZE) ? UDP_CHUNK_SIZE : remaining;
                        lwip_sendto(g_udp_sock, &RxBufferPtr[offset], chunk, 0,
                                   (struct sockaddr *)&g_pc_addr, sizeof(g_pc_addr));
                        remaining -= chunk;
                        offset += chunk;
                        // 为了不把网络堵死，发送阶段可以加延时
                         vTaskDelay(1);
                    }
                    UDP_Send_Log("[END]");
                }
            } else {
                xil_printf("!! DMA Config Error\r\n");
            }
            print_cnt++;
            vTaskDelay(pdMS_TO_TICKS(1000));
        }
        else {
            vTaskDelay(pdMS_TO_TICKS(500));
        }
    }
}
// ---------------- LED 辅助函数 ----------------
static void Set_Leds(int l1, int l2, int l3, int l4) {
    XGpioPs_WritePin(&Gpio, LED1_PIN, l1);
    XGpioPs_WritePin(&Gpio, LED2_PIN, l2);
    XGpioPs_WritePin(&Gpio, LED3_PIN, l3);
    XGpioPs_WritePin(&Gpio, LED4_PIN, l4);
}
static void Show_Binary(u8 val) {
    Set_Leds((val>>3)&1, (val>>2)&1, (val>>1)&1, (val>>0)&1);
}

// ---------------- LED 核心逻辑 (增强版) ----------------
void Task_LED_Logic(void *pvParameters) {
    int counter = 0;
    char udp_buf[64];

    // 游戏状态变量
    static int game_state = 0;
    static int last_sw_state = 0;
    static int last_dice_sw = 0;
    static TickType_t start_time = 0;

    // 初始化读取
    last_sw_state = XGpioPs_ReadPin(&Gpio, SW_BASE_PIN + 0);
    last_dice_sw  = XGpioPs_ReadPin(&Gpio, SW_BASE_PIN + 3);

    for (;;) {
        switch (g_CurrentMode) {

            case MODE_WATERFALL:
                 Set_Leds(1, 0, 0, 0); vTaskDelay(150);
                 Set_Leds(0, 1, 0, 0); vTaskDelay(150);
                 Set_Leds(0, 0, 1, 0); vTaskDelay(150);
                 Set_Leds(0, 0, 0, 1); vTaskDelay(150);
                 break;

            case MODE_SWITCH_CTRL: {
                int s1 = XGpioPs_ReadPin(&Gpio, SW_BASE_PIN + 0);
                int s2 = XGpioPs_ReadPin(&Gpio, SW_BASE_PIN + 1);
                int s3 = XGpioPs_ReadPin(&Gpio, SW_BASE_PIN + 2);
                int s4 = XGpioPs_ReadPin(&Gpio, SW_BASE_PIN + 3);
                Set_Leds(s1, s2, s3, s4);
                // 状态变化时打印太频繁，这里省略，只看灯即可
                vTaskDelay(50);
                break;
            }

            case MODE_BINARY_CNT:
                counter = (counter + 1) % 16;
                Show_Binary(counter);

                // 【新增】同时打印到串口
                xil_printf(">> Binary Count: %d\r\n", counter);

                sprintf(udp_buf, "Binary: %d [ %d %d %d %d ]", counter, (counter>>3)&1, (counter>>2)&1, (counter>>1)&1, (counter>>0)&1);
                UDP_Send_Log(udp_buf);
                vTaskDelay(1000); // 1秒跳一次，方便你看清打印
                break;

            case MODE_DICE_GAME: {
                int curr_sw = XGpioPs_ReadPin(&Gpio, SW_BASE_PIN + 3);
                if (curr_sw != last_dice_sw) {
                    last_dice_sw = curr_sw;

                    xil_printf(">> Dice Rolling...\r\n");
                    // 动画
                    for(int i=0; i<10; i++) {
                        Show_Binary(rand() % 16);
                        vTaskDelay(30 + i*10);
                    }
                    int dice = (rand() % 6) + 1;
                    Show_Binary(dice);

                    // 【新增】同时打印结果到串口
                    xil_printf(">> Dice Result: %d\r\n", dice);

                    sprintf(udp_buf, "Dice Result: %d", dice);
                    UDP_Send_Log(udp_buf);
                }
                vTaskDelay(100);
                break;
            }

            case MODE_REFLEX_GAME:
                if (game_state == 0) { // 等待
                    Set_Leds(0, 0, 0, 0);
                    vTaskDelay(2000 + (rand() % 2000));
                    Set_Leds(1, 1, 1, 1); // 亮灯
                    xil_printf(">> GO! Press Switch 1!\r\n"); // 【新增】
                    start_time = xTaskGetTickCount();
                    last_sw_state = XGpioPs_ReadPin(&Gpio, SW_BASE_PIN + 0);
                    game_state = 1;
                }
                else if (game_state == 1) { // 监测按键
                    int curr_sw = XGpioPs_ReadPin(&Gpio, SW_BASE_PIN + 0);
                    if (curr_sw != last_sw_state) {
                        TickType_t end = xTaskGetTickCount();
                        int ms = (end - start_time) * portTICK_PERIOD_MS;

                        // 【新增】同时打印成绩到串口
                        xil_printf(">> Reflex Time: %d ms\r\n", ms);

                        sprintf(udp_buf, "Reflex Time: %d ms", ms);
                        UDP_Send_Log(udp_buf);
                        game_state = 2;
                    }
                    vTaskDelay(10);
                }
                else if (game_state == 2) { // 冷却
                    vTaskDelay(2000);
                    game_state = 0;
                }
                break;

            case MODE_SOS_SIGNAL:
                xil_printf(">> Sending SOS...\r\n"); // 【新增】
                // S
                for(int i=0; i<3; i++) { Set_Leds(1,1,1,1); vTaskDelay(100); Set_Leds(0,0,0,0); vTaskDelay(100); }
                vTaskDelay(300);
                // O
                for(int i=0; i<3; i++) { Set_Leds(1,1,1,1); vTaskDelay(400); Set_Leds(0,0,0,0); vTaskDelay(100); }
                vTaskDelay(300);
                // S
                for(int i=0; i<3; i++) { Set_Leds(1,1,1,1); vTaskDelay(100); Set_Leds(0,0,0,0); vTaskDelay(100); }
                vTaskDelay(1500);
                break;

            case MODE_WAVE_OSCILLO:
                Set_Leds(1, 1, 1, 1); vTaskDelay(500); break;

            default:
                Set_Leds(0,0,0,0); vTaskDelay(100); break;
        }
    }
}

// ---------------- 系统监控任务 ----------------
void Task_System_Monitor(void *pvParameters) {
    char temp_str[32], vcc_str[32], udp_msg[64];
    vTaskDelay(pdMS_TO_TICKS(5000));
    for(;;) {
        if(g_pc_connected) {
            Read_Chip_Temp(temp_str);
            Read_Chip_Vcc(vcc_str);
            sprintf(udp_msg, "[DATA] %s, %s", temp_str, vcc_str);
            UDP_Send_Log(udp_msg);

            // 【保留】这个心跳打印保留，确认系统活着
            xil_printf("[SysMon] %s, %s\r\n", temp_str, vcc_str);
        }
        vTaskDelay(pdMS_TO_TICKS(2000));
    }
}

// ---------------- UDP 接收任务 (增强版) ----------------
void udp_cmd_thread(void *p) {
    int sock, n;
    struct sockaddr_in server_addr, client_addr;
    int addr_len = sizeof(client_addr);
    char recv_buf[100];

    if ((sock = lwip_socket(AF_INET, SOCK_DGRAM, 0)) < 0) return;
    g_udp_sock = sock;

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(5001);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (lwip_bind(sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) return;

    while (1) {
        n = lwip_recvfrom(sock, recv_buf, sizeof(recv_buf) - 1, 0,
                          (struct sockaddr *)&client_addr, (socklen_t *)&addr_len);
        if (n > 0) {
            memcpy(&g_pc_addr, &client_addr, sizeof(client_addr));
            g_pc_connected = 1;
            recv_buf[n] = 0;
            char cmd = recv_buf[0];

            if (cmd >= '0' && cmd <= '7') {
                // 【新增】在这里打印，你点一下 Python 按钮，串口就告诉你切到哪了
                xil_printf("\r\n[CMD] Received Mode Switch: %c\r\n", cmd);

                switch(cmd) {
                    case '1': g_CurrentMode = MODE_WATERFALL; xil_printf(">> Mode: Waterfall\r\n"); break;
                    case '2': g_CurrentMode = MODE_SWITCH_CTRL; xil_printf(">> Mode: Switch Control\r\n"); break;
                    case '3': g_CurrentMode = MODE_BINARY_CNT; xil_printf(">> Mode: Binary Counter\r\n"); break;
                    case '4': g_CurrentMode = MODE_DICE_GAME; xil_printf(">> Mode: Dice Game\r\n"); break;
                    case '5': g_CurrentMode = MODE_REFLEX_GAME; xil_printf(">> Mode: Reflex Test\r\n"); break;
                    case '6': g_CurrentMode = MODE_SOS_SIGNAL; xil_printf(">> Mode: SOS\r\n"); break;
                    case '7': g_CurrentMode = MODE_WAVE_OSCILLO; xil_printf(">> Mode: Oscilloscope (DMA)\r\n"); break;
                    case '0': g_CurrentMode = MODE_OFF; xil_printf(">> Mode: OFF\r\n"); break;
                }
            }
        }
    }
}
