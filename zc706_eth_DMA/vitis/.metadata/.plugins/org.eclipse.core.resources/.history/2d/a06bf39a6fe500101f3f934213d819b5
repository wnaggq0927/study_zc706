/* src/game_tasks.c - 完整版 */
#include "sys_core.h"
#include "FreeRTOS.h"
#include "task.h"
#include "xil_printf.h"
#include "xil_cache.h"
#include <stdlib.h> // rand() 需要这个
#include <stdio.h>  // sprintf 需要这个
#include <string.h> // strcat 需要这个

// ---------------- DMA 示波器任务 ----------------
void Task_DMA_Wave(void *pvParameters) {
    u32 *RxBufferPtr = (u32 *)RX_BUFFER_BASE;
    char udp_big_buf[1024];
    char temp_buf[16];

    // 硬件初始化已在 sys_core.c 完成，这里只需延时等待网络
    vTaskDelay(pdMS_TO_TICKS(5000));

    for(;;) {
        if (g_CurrentMode == MODE_WAVE_OSCILLO && g_pc_connected) {
            // 1. 启动传输
            Xil_DCacheInvalidateRange((UINTPTR)RxBufferPtr, MAX_PKT_LEN);
            int Status = XAxiDma_SimpleTransfer(&AxiDma, (UINTPTR)RxBufferPtr,
                                            MAX_PKT_LEN, XAXIDMA_DEVICE_TO_DMA);
            // 2. 等待完成
            if (Status == XST_SUCCESS) {
                while (XAxiDma_Busy(&AxiDma, XAXIDMA_DEVICE_TO_DMA)) { vTaskDelay(1); }

                // 3. 读数据
                Xil_DCacheInvalidateRange((UINTPTR)RxBufferPtr, MAX_PKT_LEN);
                strcpy(udp_big_buf, "[WAVE] ");
                // 为了演示只取前 50 个点，防止包太大
                for(int i=0; i<50; i++) {
                    int8_t val = (int8_t)(RxBufferPtr[i] & 0xFF);
                    sprintf(temp_buf, "%d,", val);
                    strcat(udp_big_buf, temp_buf);
                }
                UDP_Send_Log(udp_big_buf);
            }
        }
        // 示波器刷新率 20Hz (50ms)
        vTaskDelay(pdMS_TO_TICKS(50));
    }
}

// ---------------- LED 辅助函数 ----------------
static void Set_Leds(int l1, int l2, int l3, int l4) {
    XGpioPs_WritePin(&Gpio, LED1_PIN, l1);
    XGpioPs_WritePin(&Gpio, LED2_PIN, l2);
    XGpioPs_WritePin(&Gpio, LED3_PIN, l3);
    XGpioPs_WritePin(&Gpio, LED4_PIN, l4);
}

static void Show_Binary(u8 val) {
    Set_Leds((val>>3)&1, (val>>2)&1, (val>>1)&1, (val>>0)&1);
}

// ---------------- LED 核心逻辑任务 (修复版) ----------------
void Task_LED_Logic(void *pvParameters) {
    int counter = 0;
    char udp_buf[64];

    // 反应力游戏需要的静态变量
    static int game_state = 0;
    static int last_sw_state = 0;
    static TickType_t start_time = 0;

    // 骰子游戏需要的变量
    static int last_dice_sw = 0;

    // 初始化一下开关状态
    last_sw_state = XGpioPs_ReadPin(&Gpio, SW_BASE_PIN + 0);
    last_dice_sw  = XGpioPs_ReadPin(&Gpio, SW_BASE_PIN + 3);

    for (;;) {
        switch (g_CurrentMode) {

            // --- 模式 1: 流水灯 ---
            case MODE_WATERFALL:
                 Set_Leds(1, 0, 0, 0); vTaskDelay(150);
                 Set_Leds(0, 1, 0, 0); vTaskDelay(150);
                 Set_Leds(0, 0, 1, 0); vTaskDelay(150);
                 Set_Leds(0, 0, 0, 1); vTaskDelay(150);
                 break;

            // --- 模式 2: 开关直控 (补回) ---
            case MODE_SWITCH_CTRL: {
                int s1 = XGpioPs_ReadPin(&Gpio, SW_BASE_PIN + 0);
                int s2 = XGpioPs_ReadPin(&Gpio, SW_BASE_PIN + 1);
                int s3 = XGpioPs_ReadPin(&Gpio, SW_BASE_PIN + 2);
                int s4 = XGpioPs_ReadPin(&Gpio, SW_BASE_PIN + 3);
                Set_Leds(s1, s2, s3, s4);
                vTaskDelay(50);
                break;
            }

            // --- 模式 3: 二进制计数 ---
            case MODE_BINARY_CNT:
                counter = (counter + 1) % 16;
                Show_Binary(counter);
                sprintf(udp_buf, "Binary: %d [ %d %d %d %d ]", counter, (counter>>3)&1, (counter>>2)&1, (counter>>1)&1, (counter>>0)&1);
                UDP_Send_Log(udp_buf);
                vTaskDelay(500);
                break;

            // --- 模式 4: 电子骰子 (补回) ---
            case MODE_DICE_GAME: {
                int curr_sw = XGpioPs_ReadPin(&Gpio, SW_BASE_PIN + 3); // 假设用 SW4 触发
                if (curr_sw != last_dice_sw) {
                    last_dice_sw = curr_sw;
                    // 动画效果
                    for(int i=0; i<10; i++) {
                        Show_Binary(rand() % 16);
                        vTaskDelay(30 + i*10);
                    }
                    int dice = (rand() % 6) + 1;
                    Show_Binary(dice);
                    sprintf(udp_buf, "Dice Result: %d", dice);
                    UDP_Send_Log(udp_buf);
                }
                vTaskDelay(100);
                break;
            }

            // --- 模式 5: 反应力测试 (补回) ---
            case MODE_REFLEX_GAME:
                // 阶段 0: 等待随机时间
                if (game_state == 0) {
                    Set_Leds(0, 0, 0, 0);
                    int delay = 2000 + (rand() % 2000);
                    vTaskDelay(delay);
                    // 亮灯，开始计时
                    Set_Leds(1, 1, 1, 1);
                    start_time = xTaskGetTickCount();
                    last_sw_state = XGpioPs_ReadPin(&Gpio, SW_BASE_PIN + 0); // 记录当前开关状态
                    game_state = 1;
                }
                // 阶段 1: 等待开关动作
                else if (game_state == 1) {
                    int curr_sw = XGpioPs_ReadPin(&Gpio, SW_BASE_PIN + 0);
                    if (curr_sw != last_sw_state) {
                        TickType_t end = xTaskGetTickCount();
                        int ms = (end - start_time) * portTICK_PERIOD_MS;

                        sprintf(udp_buf, "Reflex Time: %d ms", ms);
                        UDP_Send_Log(udp_buf);

                        game_state = 2; // 进入冷却
                    }
                    vTaskDelay(10);
                }
                // 阶段 2: 冷却重置
                else if (game_state == 2) {
                    vTaskDelay(2000);
                    game_state = 0;
                }
                break;

            // --- 模式 6: SOS 信号 (补回) ---
            case MODE_SOS_SIGNAL:
                // S (...)
                for(int i=0; i<3; i++) { Set_Leds(1,1,1,1); vTaskDelay(100); Set_Leds(0,0,0,0); vTaskDelay(100); }
                vTaskDelay(300);
                // O (---)
                for(int i=0; i<3; i++) { Set_Leds(1,1,1,1); vTaskDelay(400); Set_Leds(0,0,0,0); vTaskDelay(100); }
                vTaskDelay(300);
                // S (...)
                for(int i=0; i<3; i++) { Set_Leds(1,1,1,1); vTaskDelay(100); Set_Leds(0,0,0,0); vTaskDelay(100); }
                vTaskDelay(1500);
                break;

            // --- 模式 7: 示波器 (LED 常亮表示工作中) ---
            case MODE_WAVE_OSCILLO:
                Set_Leds(1, 1, 1, 1);
                vTaskDelay(500);
                break;

            // --- 关机 ---
            case MODE_OFF:
                Set_Leds(0,0,0,0); vTaskDelay(100); break;

            default:
                Set_Leds(0,0,0,0); vTaskDelay(100); break;
        }
    }
}

// ---------------- 系统监控任务 ----------------
void Task_System_Monitor(void *pvParameters) {
    char temp_str[32], vcc_str[32], udp_msg[64];
    vTaskDelay(pdMS_TO_TICKS(5000));
    for(;;) {
        if(g_pc_connected) {
            Read_Chip_Temp(temp_str);
            Read_Chip_Vcc(vcc_str);
            sprintf(udp_msg, "[DATA] %s, %s", temp_str, vcc_str);
            UDP_Send_Log(udp_msg);
        }
        vTaskDelay(pdMS_TO_TICKS(2000));
    }
}

// ---------------- UDP 接收任务 ----------------
void udp_cmd_thread(void *p) {
    int sock, n;
    struct sockaddr_in server_addr, client_addr;
    int addr_len = sizeof(client_addr);
    char recv_buf[100];

    if ((sock = lwip_socket(AF_INET, SOCK_DGRAM, 0)) < 0) return;
    g_udp_sock = sock;

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(5001);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (lwip_bind(sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) return;

    while (1) {
        n = lwip_recvfrom(sock, recv_buf, sizeof(recv_buf) - 1, 0,
                          (struct sockaddr *)&client_addr, (socklen_t *)&addr_len);
        if (n > 0) {
            memcpy(&g_pc_addr, &client_addr, sizeof(client_addr));
            g_pc_connected = 1;
            recv_buf[n] = 0;
            char cmd = recv_buf[0];

            if (cmd >= '0' && cmd <= '7') {
                switch(cmd) {
                    case '1': g_CurrentMode = MODE_WATERFALL; break;
                    case '2': g_CurrentMode = MODE_SWITCH_CTRL; break;
                    case '3': g_CurrentMode = MODE_BINARY_CNT; break;
                    case '4': g_CurrentMode = MODE_DICE_GAME; break;
                    case '5': g_CurrentMode = MODE_REFLEX_GAME; break;
                    case '6': g_CurrentMode = MODE_SOS_SIGNAL; break;
                    case '7': g_CurrentMode = MODE_WAVE_OSCILLO; break;
                    case '0': g_CurrentMode = MODE_OFF; break;
                }
            }
        }
    }
}
